#include "v2vcustom/V2VApp.h"
#include "inet/common/packet/chunk/BytesChunk.h"
#include "inet/common/packet/Packet.h"
#include "inet/networklayer/common/L3AddressResolver.h"
#include <random>

Define_Module(V2VApp);

V2VApp::~V2VApp() {
    if (sendTimer) {
        cancelAndDelete(sendTimer);
        sendTimer = nullptr;
    }
    try { socket.close(); } catch (...) {}
}

void V2VApp::initialize(int stage) {
    ApplicationBase::initialize(stage);

    if (stage == INITSTAGE_LOCAL) {
        EV << "âœ… Custom V2VApp initialized on node: " << getParentModule()->getFullName() << endl;
        bubble("Custom V2VApp running!");

        localPort = par("localPort");
        destPort = par("destPort");
        sendInterval = par("sendInterval");
        sendTimer = new cMessage("sendTimer");

        // read malicious params
        malicious = par("malicious").boolValue();
        attackType = par("attackType").stdstringValue();
        attackCounter = 0;

        // Additional attack parameters
        spoofedSourceId = par("spoofedSourceId").stdstringValue();
        dataManipulationProbability = par("dataManipulationProbability").doubleValue();

        // Initialize random generator for attacks
        randomGenerator.seed(std::random_device{}());

        if (malicious) {
            EV_WARN << "**** Node " << getParentModule()->getFullName()
                    << " configured as MALICIOUS (type=" << attackType << ") ****\n";
            bubble("MALICIOUS");
        } else {
            EV_INFO << "Node " << getParentModule()->getFullName() << " is normal\n";
        }
    }
}

void V2VApp::handleStartOperation(LifecycleOperation *operation) {
    // Setup socket at startup
    socket.setOutputGate(gate("socketOut"));
    socket.bind(localPort);              // open() no longer needed in INET 4.5
    socket.setBroadcast(true);

    // Destination: broadcast
    destAddr = L3AddressResolver().resolve("255.255.255.255");

    // Schedule first send
    scheduleAt(simTime() + uniform(0, sendInterval), sendTimer);

    EV_INFO << "V2VApp started on " << getFullPath()
            << " (localPort=" << localPort << ", destPort=" << destPort << ")\n";
}

void V2VApp::handleStopOperation(LifecycleOperation *operation) {
    cancelEvent(sendTimer);
    socket.close();
    EV_INFO << "V2VApp stopped on " << getFullPath() << "\n";
}

void V2VApp::handleCrashOperation(LifecycleOperation *operation) {
    cancelEvent(sendTimer);
    try { socket.close(); } catch (...) {}
    EV_WARN << "V2VApp crashed on " << getFullPath() << "\n";
}

void V2VApp::handleMessageWhenUp(cMessage *msg) {
    if (msg == sendTimer) {
        sendPacket();
        scheduleAt(simTime() + sendInterval, sendTimer);
    }
    else if (auto pk = dynamic_cast<Packet *>(msg)) {
        receivePacket(pk);
    }
    else {
        socket.processMessage(msg);
    }
}

void V2VApp::sendPacket() {
    Packet *pk = new Packet("V2VMessage");

    if (!malicious) {
        // normal payload: 100 zero bytes
        std::vector<uint8_t> v(100, 0);
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_INFO << "[" << getParentModule()->getFullName() << "] sending normal message\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }

    // MALICIOUS BEHAVIOR
    attackCounter++;

    if (attackType == "flood") {
        // Flood attack: larger payload, faster sending controlled via ini
        std::vector<uint8_t> v(1400, 0xAA);
        v[0] = 0xFF; // mark first byte so receivers can detect
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] FLOOD pkt #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "spoof") {
        // Spoof attack: include fake source id in payload
        std::string msg = "SPOOF_SRC=" + spoofedSourceId + ";SEQ=" + std::to_string(attackCounter);
        std::vector<uint8_t> v(msg.begin(), msg.end());
        v.resize(200, 0);
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullPath() << "] sending SPOOF message as " << spoofedSourceId << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "replay") {
        // Replay attack: replay old messages with timestamps
        std::string msg = "REPLAY_ATTACK;ORIG_TIME=" + std::to_string(simTime().dbl() - 1000) +
                         ";REPLAY_TIME=" + std::to_string(simTime().dbl());
        std::vector<uint8_t> v(msg.begin(), msg.end());
        v.resize(150, 0);
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] REPLAY attack #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "selective_forwarding") {
        // Selective forwarding: randomly drop packets (simulated by not sending some)
        std::uniform_real_distribution<double> dist(0.0, 1.0);
        if (dist(randomGenerator) < 0.3) { // 30% packet drop
            EV_WARN << "[" << getParentModule()->getFullName() << "] SELECTIVE_FORWARDING - dropping packet #" << attackCounter << "\n";
            delete pk;
            return;
        }
        // Otherwise send normal-looking packet
        std::vector<uint8_t> v(100, 0);
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] SELECTIVE_FORWARDING - forwarding packet #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "data_manipulation") {
        // Data manipulation: corrupt message content
        std::vector<uint8_t> v(100, 0);

        // Create a normal-looking message but with manipulated data
        std::string baseMsg = "POSITION:X=" + std::to_string(100 + attackCounter) + ",Y=200";
        if (baseMsg.length() < v.size()) {
            std::copy(baseMsg.begin(), baseMsg.end(), v.begin());
        }

        // Manipulate random bytes in the payload
        std::uniform_int_distribution<size_t> byteDist(0, v.size()-1);
        std::uniform_int_distribution<uint8_t> valueDist(1, 255);

        size_t manipulationCount = static_cast<size_t>(v.size() * dataManipulationProbability);
        for (size_t i = 0; i < manipulationCount; ++i) {
            v[byteDist(randomGenerator)] = valueDist(randomGenerator);
        }

        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] DATA_MANIPULATION attack #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "sybil") {
        // Sybil attack: simulate multiple identities
        std::vector<std::string> fakeIds = {"node_A", "vehicle_123", "sensor_45", "car_emergency"};
        std::uniform_int_distribution<size_t> idDist(0, fakeIds.size()-1);

        std::string fakeId = fakeIds[idDist(randomGenerator)];
        std::string msg = "SYBIL_ATTACK;ID=" + fakeId + ";REAL_ID=" + getParentModule()->getFullName();
        std::vector<uint8_t> v(msg.begin(), msg.end());
        v.resize(180, 0);
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] SYBIL attack as " << fakeId << " #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "timing") {
        // Timing attack: send messages with irregular timing patterns
        // This is handled by modifying the sendInterval dynamically
        if (attackCounter % 10 == 0) {
            // Burst mode: send several packets quickly
            for (int i = 0; i < 5; i++) {
                Packet *burstPk = new Packet("V2VMessage_Burst");
                std::vector<uint8_t> v(120, 0xBB);
                auto payload = makeShared<BytesChunk>(v);
                burstPk->insertAtBack(payload);
                socket.sendTo(burstPk, destAddr, destPort);
            }
            EV_WARN << "[" << getParentModule()->getFullName() << "] TIMING attack - BURST mode #" << attackCounter << "\n";
        }

        // Regular timing attack packet
        std::vector<uint8_t> v(100, 0xCC);
        v[0] = 0xFD; // Timing attack marker
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] TIMING attack packet #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else if (attackType == "hello_flood") {
        // Hello Flood attack: send excessive hello/beacon messages
        std::string msg = "HELLO_FLOOD;NODE=" + getParentModule()->getFullName() +
                         ";TIME=" + std::to_string(simTime().dbl());
        std::vector<uint8_t> v(msg.begin(), msg.end());
        v.resize(80, 0); // Smaller packets for hello flood

        // Send multiple copies
        for (int i = 0; i < 3; i++) {
            Packet *helloPk = new Packet("V2VHello");
            auto payload = makeShared<BytesChunk>(v);
            helloPk->insertAtBack(payload);
            socket.sendTo(helloPk, destAddr, destPort);
        }

        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] HELLO_FLOOD attack #" << attackCounter << "\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
    else {
        // Default malicious: abnormal marker + medium size
        std::vector<uint8_t> v(200, 0x00);
        v[0] = 0xFE;
        auto payload = makeShared<BytesChunk>(v);
        pk->insertAtBack(payload);
        EV_WARN << "[" << getParentModule()->getFullName() << "] sending unknown-attack payload\n";
        socket.sendTo(pk, destAddr, destPort);
        return;
    }
}

void V2VApp::receivePacket(Packet *pk) {
    EV_INFO << "Received packet '" << pk->getName()
            << "' at " << getFullPath()
            << " (time=" << simTime() << ")\n";
    delete pk;
}

void V2VApp::finish() {
    if (malicious) {
        EV_WARN << "[" << getParentModule()->getFullName() << "] Malicious node statistics: "
                << attackCounter << " attack packets sent (type: " << attackType << ")\n";
    }
    cancelEvent(sendTimer);
    socket.close();
    ApplicationBase::finish();
}
